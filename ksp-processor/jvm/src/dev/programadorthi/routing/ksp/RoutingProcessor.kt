package dev.programadorthi.routing.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ksp.writeTo
import dev.programadorthi.routing.annotation.Route

public class RoutingProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return RoutingProcessor(
            codeGenerator = environment.codeGenerator,
            logger = environment.logger
        )
    }
}

private class RoutingProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {
    private var invoked = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (invoked) {
            return emptyList()
        }
        invoked = true

        val configureSpec = FunSpec
            .builder("configure")
            .addModifiers(KModifier.INTERNAL)
            .receiver(dev.programadorthi.routing.core.Route::class)

        resolver
            .getSymbolsWithAnnotation(Route::class.java.name)
            .filterIsInstance<KSFunctionDeclaration>()
            .forEach { func ->
                check(func.packageName.asString().isNotBlank()) {
                    "Local functions are not supported. " +
                        "Please provide a package to fun '${func.qualifiedName?.asString()}'"
                }

                val annotation = func.getAnnotationByName("Route")
                val path = annotation?.getArgumentValueByName<String>("value")

                configureSpec.addCode(
                    """
                        |handle(path = "$path") {
                        |    ${func.qualifiedName?.asString()}()
                        |}
                        |""".trimMargin()
                )
            }

        FileSpec
            .builder(
                packageName = "dev.programadorthi.routing.generated",
                fileName = "ModuleRoutes"
            )
            .addFileComment("Generated by Kotlin Routing")
            .addImport("dev.programadorthi.routing.core", "handle")
            .addFunction(configureSpec.build())
            .build()
            .writeTo(
                codeGenerator = codeGenerator,
                dependencies = Dependencies.ALL_FILES
            )

        return emptyList()
    }

}

private fun KSFunctionDeclaration.getAnnotationByName(name: String): KSAnnotation? =
    annotations.firstOrNull { it.shortName.asString() == name }

private fun <T> KSAnnotation.getArgumentValueByName(name: String): T? =
    arguments.firstOrNull { it.name?.asString() == name }?.value as? T
